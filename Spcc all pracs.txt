Creating your library in Linux Environment
1.      Power Function
powshared.c :
#include<stdio.h>
int power(int b,int e)
{                  if(e>1)                      return b*power(b,e-1);                    
                    return b;                  }
 
powshared.h :
#include<stdio.h>
#include "powshared.c"
extern int power(int b,int e);
 
powmain.h :
#include<stdio.h>
#include "powshared.h"
int main()
{                  int b,e;
                    printf("Enter base = ");
                    scanf("%d",&b);
                    printf("Enter exponent = ");
                    scanf("%d",&e);
                    printf("%d to the power %d = %d\n",b,e,power(b,e));
                    return 0;                  }
 
2.      Factorial Function
factshared.c :
#include<stdio.h>
int fact(int f)
{                  if(f>=1)                     return f*fact(f-1);
                    else                            return 1;                  }
 
factshared.h :
#include<stdio.h>
#include "factshared.c"
extern int fact(int f);
 
factmain.c :
#include<stdio.h>
#include "factshared.h"
int main()
{                  int f;
                    printf("Enter a number = ");
                    scanf("%d",&f);
                    printf("Factorial = %d\n",fact(f));
                    return 0;                  }
 
 
 
 
 
 
 
3.      Square Root Function
sqrootshared.c :
#include<stdio.h>
#include<math.h>
int sqroot(int n)
{                  int i,x=1,c=0;
                    for(i=1;x<=n;i+=2)
            {          x=x+i;
                c++;               }
                    return c;                   }
sqrootshared.h :
#include<stdio.h>
#include "sqrootshared.c"
extern int sqroot(int n);
 
sqrootmain.c :
#include<stdio.h>
#include "sqrootshared.h"
int main()
{                  int b;
                    printf("Enter a number = ");
                    scanf("%d",&b);
                    printf("Square root = %d\n",sqroot(b));
                    return 0;                  }




Lexical Analyzer


#include<stdio.h>
#include<conio.h>
#include<ctype.h>
#include<string.h>
#include<stdlib.h>


int keyword_library(char temp[]);


int main()
{
      char ch, temp[40], arithmetic_operator[] = "=+%*/-";
      FILE *file_pointer;
      int count, x = 0,ck=0,ci=0,co=0;
      file_pointer = fopen("Add.txt","r");
      if(file_pointer == NULL)
      {
            printf("The file could not be opened.\n");
            exit(0);
      }
      while((ch = fgetc(file_pointer)) != EOF)
      {
            count = 0;
            while(count <= 5)
            {
                  if(ch == arithmetic_operator[count])
                  {
                        printf("\nOperator:\t%c", ch);
                        co++;
                  }
                  count = count + 1;
            }
            if(isalnum(ch))
            {
                  temp[x++] = ch;
            }
            else if((ch == '\n' || ch == ' ') && (x != 0))
            {
                  temp[x] = '\0';
                  x = 0;
                  if(keyword_library(temp) == 1)
                  {
                        printf("\nKeyword:\t%s", temp);
                        ck++;
                  }
                  else
                  {
                        printf("\nIdentifier:\t%s", temp);
                        ci++;
                  }
            }
      }
      fclose(file_pointer);
      printf("\n\nCount of Keywords = %d",ck);
      printf("\nCount of Identifiers = %d",ci);
      printf("\nCount of Operators = %d",co);
      getch();
      return 0;
}


int keyword_library(char temp[])
{
      int count = 0, flag = 0;
      char keywords[32][12] = {"return", "continue", "extern", "static", "long", "signed",
                               "switch", "char", "else", "unsigned", "if", "struct",
                               "union", "goto", "while", "float", "enum", "sizeof", "double", "volatile",
                               "const", "case", "for", "break", "void", "register", "int",
                               "do", "default", "short", "typedef", "auto"};
      while(count <= 31)
      {
            if(strcmp(keywords[count], temp) == 0)
            {
                  flag = 1;
                  break;
            }
            count = count + 1;
      }
      return (flag);
}


Add.txt
#include<stdio.h>
int main()
{
    int t,q,r;
    t=q%r;
}


FLEX
1. Count the number of vowels and consonants
%{
#include<stdio.h>
#include<stdlib.h>
int v=0;
int c=0;
%}
%%
[aeiouAEIOU] { v++; };
[a-zA-Z] { c++; };
%%
int main()
{
printf("Enter the String:");
yylex();
printf("No. of Vowels=%d\n",v);
printf("No. of Consonants=%d\n",c);
}
2.) Count the number of printf and scanf
%{
#include<stdio.h>
int p=0, s=0;
%}
%%
printf {p++;}
scanf {s++;}
[a-zA-Z] {}
%%
int main()
{
printf("Enter the String:");
yylex();
printf("no. of scanf %d\n",s);
printf("no. of printf %d\n",p);
return 0;}


3.) Count the number of Verb, Adverb and Adjective
%{
#include<stdio.h>
#include<stdlib.h>
int v=0;
int av=0;
int aj=0;
%}
%%
[\t]
go(es) |
runs |
likes v++;
quickly |
slow |
lazy |
slowly av++;
small aj++;
[a-zA-Z]
%%
int main()
{
printf("Enter the String:");
yylex();
printf("no. of verb %d\n",v);
printf("no. of adverb %d\n",av);
printf("no. of adjective %d\n",aj);
return 0;
}


4.)  Check whether number is Even or odd
%{
#include<stdio.h>
#include<stdlib.h>
%}
%%
[0-9]*[02468] {printf("Even number");}
[0-9]*[13579] {printf("Odd number");}
-[0-9]*[02468] {printf("Even number");}
-[0-9]*[13579] {printf("Odd number");}
%%
int main() {
printf("Enter any number");
yylex();
}
5.)  Count no Characters,                                     white spaces,lines,words
%{
#include<stdio.h>
int c=0, w=0, l=0, s=0;
%}
%%
[\n] {l++;}
[' '] {s++;}
[^' '\t\n]+ {w++;c=c+yyleng;}
%%
int main()
{
printf("Enter the String : ");
yylex();
printf("no. of spaces %d\n",s);
printf("no. of characters %d\n",c);
printf("no. of words %d\n",w);
printf("no. of lines %d\n",l);
return 0;
FIRST & FOLLOW


#include<stdio.h>
#include<conio.h>
#include<String.h>
 int n,m=0,p,i=0,j=0;
 char a[10][10],f[10];
 void follow(char c);
 void first(char c);
 int main(){
   int i,z;
   char c,ch;
   printf("Enter the no of productions:\n");
   scanf("%d",&n);
   printf("Enter the productions:\n");
   for(i=0;i<n;i++)
    scanf("%s%c",a[i],&ch);
    do{
     m=0;
     printf("Enter the elements whose first & follow is to be found:");
     scanf("%c",&c);
     first(c);
     printf("First(%c)={",c);
     for(i=0;i<m;i++)
      printf("%c",f[i]);
      printf("}\n");
      strcpy(f," ");
      //flushall();
      m=0;
      follow(c);
      printf("Follow(%c)={",c);
       for(i=0;i<m;i++)
 printf("%c",f[i]);
 printf("}\n");
 printf("Continue(0/1)?");
 scanf("%d%c",&z,&ch);
     }while(z==1);
      return(0);  }
void first(char c) {
  int k;
   if(!isupper(c))
    f[m++]=c;
     for(k=0;k<n;k++)  {
       if(a[k][0]==c) {
   if(a[k][2]=='$')
    follow(a[k][0]);
   else if(islower(a[k][2]))
    f[m++]=a[k][2];
   else first(a[k][2]);
 }    }  }
 void follow(char c)  {
   if(a[0][0]==c)
    f[m++]='$';
   for(i=0;i<n;i++)
    {
     for(j=2;j<strlen(a[i]);j++)
      {
       if(a[i][j]==c)
 {
   if(a[i][j+1]!='\0')
     first(a[i][j+1]);
    if(a[i][j+1]=='\0' && c!=a[i][0])
     follow(a[i][0]);
  }}}}


YACC


Recognize nested if statements and display levels :
IF.l
%{
#include "y.tab.h"
#define yywrap() 1
%}
%%
"if" return IF;
[sS][0-9]* return STOP;
"<"|">"|"=="|"<="|">="|"!=" return CONDITION;
[0-9]+ return NUMBER;
[a-z][a-zA-Z0-9_]* return IDENTIFIER;
\n return NEWLINE;
. return yytext[0];
%%
IF.y
%{
#include<stdio.h>
int count=0;
%}
%token IF CONDITION STOP NUMBER IDENTIFIER NEWLINE
%%
statement : if_stmt NEWLINE {printf("\nNo. of nested if statements = %d\n",count);}
if_stmt : IF'('cond')''{'if_stmt'}' {count++;}
          |STOP
cond : IDENTIFIER CONDITION NUMBER | NUMBER CONDITION IDENTIFIER | IDENTIFIER CONDITION IDENTIFIER
%%
int yyerror()
{
printf("\nThe statement is invalid.\n");
}
main()
{
printf("\nEnter the statement : \n");
yyparse();
}


Simple Calculator :
Cal.l
%{
#include<stdio.h>
#include<math.h>
#include "y.tab.h"
%}
%%
[0-9]+ {yylval.dval=atoi(yytext); return NUMBER; }
[\n] {return 0;}
[ \t] {;}
. {return yytext[0];}
%%
int yywrap(void)
{        return 1;        }
void yyerror(char *str)
{         printf(" Error : %s",str);        }
int main()
{         printf("Enter Expression => ");
 yyparse();
 return(0);        }
Cal.y
%{
#include<stdio.h>
int yylex(void);
%}
%union
{         float dval;        }
%token <dval> NUMBER
%left '+' '-'
%left '*' '/'
%nonassoc UMINUS
%type <dval> exp
%%
state : exp {printf("Answer = %f",$1);}
 ;
exp : NUMBER
 | exp '+' exp {$$=$1+$3;}
 | exp '-' exp {$$=$1-$3;}
 | exp '*' exp {$$=$1*$3;}
 | exp '/' exp {$$=$1/$3;}
 | '('exp')' {$$=$2;}
 | '-' exp %prec UMINUS {$$=-$2;}
 ;
%%




Recognize a valid variable in C :
Val.l
%{
#include "y.tab.h"
#define yywrap() 1
%}
%%
[a-zA-Z] return ID;
[0-9] return NUMBER;
[_] return UNDERSCORE;
\n return NEWLINE;
. return yytext[0];
%%


Val.y
%{
#include<stdio.h>
#include<stdlib.h>
%}
%token ID NUMBER UNDERSCORE NEWLINE 
%%
statement : start NEWLINE {printf("\nIt is a valid C variable.\n");exit(0);}
start : ID next | UNDERSCORE next
next : ID next | UNDERSCORE next | NUMBER next | NUMBER | UNDERSCORE | ID
%%
int yyerror()
{
        printf("\nInvalid C variable.\n");
        exit(0);
}
main()
{
        printf("Enter a variable name : ");
        yyparse();
}


PARSER
1.      LL(1)
Input :
import java.util.*;
class PredictiveParser {
                    public static void main(String args[]) {
                                    String var = "EFT",ter = "i+()$",table [][]={{"TF","-","TF","-","-"},{"-","+TF","-","e","e"},{"i","-","(E)","-","-"}},ip1 = "i+i$", value;
                                    int i,j;
                                    char ip2[] = new char[10], c1, c2;
                                    ip2 = ip1.toCharArray();
                                    Stack ip = new Stack();
                                    for(i = ip2.length-1;i >= 0;i--)
                                                    ip.push(""+ip2[i]);
                                    Stack stack = new Stack();
                                    stack.push("$");
                                    stack.push(var.charAt(0));
                                    System.out.print("\nPredictive Parser / LL(1) Parser Table : \n\n\t ");
                                    for(i=0;i<ter.length();i++)
                                                    System.out.print(ter.charAt(i)+"\t");
                                    System.out.println("\n\t----------------------------------");
                                    for(i=0;i<var.length();i++)
                                    {
                                                    System.out.print("\n"+var.charAt(i)+"   |\t");
                                                    for(j=0;j<ter.length();j++)
                                                                    System.out.print(table[i][j]+"\t");
                                    }
                                    System.out.printf("\n%-20s %-20s\n\n","\n\nSTACK","INPUT");
                                    while(true) {
                                                    for(i=0;i<stack.size();i++)
                                                                    System.out.print(stack.get(i)+" ");
                                                    if(stack.size()>3)
                                                                    System.out.print("\t");
                                                    else
                                                                    System.out.printf("\t\t");
                                                    for(i=ip.size()-1;i>=0;i--)
                                                                    System.out.print(ip.get(i)+" ");
                                                    System.out.println();
                                                    c1 = stack.peek().toString().charAt(0);
                                                    c2 = ip.peek().toString().charAt(0);
                                                    if( (c1 == c2 && c2 == '$') || (c1 == 'e' && c2 == '$') )
                                                    {
                                                                    System.out.printf("%-20s\n","Accept!");
                                                                    break;
                                                    }
                                                    else if(c1 == c2 && c2 != '$')
                                                    {
                                                                    try
                                                                    {
                                                                                    stack.pop();
                                                                                    ip.pop();
                                                                    }
                                                                    catch(EmptyStackException e) {}
                                                    }
                                                    else if(table[var.indexOf(c1)][ter.indexOf(c2)] != "-")
                                                    {
                                                                    try
                                                                    {
                                                                                    stack.pop();
                                                                    }
                                                                    catch(EmptyStackException e) {}
                                                                    value = table[var.indexOf(c1)][ter.indexOf(c2)];
                                                                    for(i = (value.length())-1;i >= 0;i--)
                                                                                    stack.push(""+(value.charAt(i)));
                                                    }
                                                    else {
                                                                    System.out.println("Error");
                                                                    break;
                                                    }
                                    }
                    }
}


1.      LALR(1)
Input :
import java.util.Stack;
import java.util.Arrays;
class LALR
{
                    public static void main(String args[])
                    {
                                    String table[][] = {{"S36","S47","-","1","2"},{"-","-","Accept!","-","-"},{"S36","S47","-","-","5"},{"S36","S47","-","-","89"},{"r3","r3","r3","-","-"},{"-","-","r1","-","-"},{"r2","r2","r2","-","-",}}, r[][] = {{"S","AA"},{"A","aA"},{"A","b"}};;
                                    String ter = "ab$SA",input = "aabb",stat[] = {"0","1","2","36","47","5","89"};
                                    Stack stack = new Stack(),ip = new Stack();
                                    stack.push("$");
                                    stack.push("0");
                                    ip.push("$");
                                    int i,j;
                                    for(i=input.length()-1;i>=0;i--)
                                                    ip.push(input.charAt(i)+"");
                                    System.out.println("\nAugmented Grammer :\n");
                                    for(i=0;i<r.length;i++)
                                                    System.out.println(i+1+") "+r[i][0]+" -> "+r[i][1]);
                                    System.out.print("\nLALR Parser Table : \n\n\t ");
                                    for(i=0;i<ter.length();i++)
                                                    System.out.print(ter.charAt(i)+"\t");
                                    System.out.println("\n\t----------------------------------");
                                    for(i=0;i<stat.length;i++)
                                    {
                                                    System.out.print("\n"+stat[i]);
                                                    if(stat[i].length()==1)
                                                                    System.out.print("   |\t");
                                                    else
                                                                    System.out.print("  |\t");
                                                    for(j=0;j<ter.length();j++)
                                                                    System.out.print(table[i][j]+"\t");
                                    }
                                    System.out.printf("\n%20s%24s\n\n","\n\nSTACK","INPUT");
                                    String x,a,t,x2;
                                    while(true)
                                    {
                                                    for(i=0;i<stack.size();i++)
                                                                    System.out.print(stack.get(i)+" ");
                                                    if(stack.size()<4)
                                                                    System.out.print("\t\t\t");
                                                    else if(stack.size()>3&&stack.size()<7)
                                                                    System.out.print("\t\t");
                                                    else
                                                                    System.out.print("\t");
                                                    for(i=ip.size()-1;i>=0;i--)
                                                                    System.out.print(ip.get(i)+" ");
                                                    System.out.println();
                                                    x = stack.peek().toString();
                                                    a = ip.peek().toString();
                                                    if(Arrays.asList(stat).contains(x))
                                                    {
                                                                    for(i=0;i<stat.length&&!stat[i].equals(x);i++);
                                                                    t = table[i][ter.indexOf(a)];
                                                                    if(t.contains("S"))
                                                                    {
                                                                                    ip.pop();
                                                                                    stack.push(a);
                                                                                    stack.push(t.substring(1));              
                                                                    }
                                                                    else if(t.contains("r"))
                                                                    {                  
                                                                                    for(i=0;i<r[Integer.parseInt(t.substring(1))-1][1].length();i++)
                                                                                    {                  stack.pop();
                                                                                                    stack.pop();            }
                                                                                    stack.push(r[Integer.parseInt(t.substring(1))-1][0]);            }
                                                                    else
                                                                    {                  System.out.println("\nAccept!");
                                                                                    break;   }                 }
                                                    else
                                                    {                  x2 = (stack.get(stack.size()-2)).toString();
                                                                    for(i=0;i<stat.length&&!stat[i].equals(x2);i++);
                                                                    t = table[i][ter.indexOf(x)];
                                                                    stack.push(t);         }                 }                  }                  }
1.      Operator Precedence
Input :
import java.util.Stack;
import java.util.Arrays;
public class OperatorPrecedence
{               public static void main(String args[])
        {           String ter = "i+*$";
            char prec[][] = {{'-','>','>','>'},{'<','>','<','>'},{'<','>','>','>'},{'<','<','<','A'}};
            String prod[] = {"E","E+E","E*E","i"},input = "i+i",temp="";
            Stack<Character> stack = new Stack<Character>(), ip = new Stack<Character>();
        stack.push((Character)'$');
            ip.push((Character)'$');
                            int i,j,k,l;
                            for(i=input.length()-1;i>=0;i--)
            ip.push((Character)input.charAt(i));
            char a,b,p;
                            System.out.print("\n"+prod[0]+" -> ");
                            for(i=1;i<prod.length;i++)
                                        if(i==prod.length-1)
                                                    System.out.print(prod[i]);
                                        else
                                                    System.out.print(prod[i]+" | ");
                            System.out.print("\n\n\t");
                            for(i=0;i<ter.length();i++)
                                        System.out.print(ter.charAt(i)+"\t");
                            System.out.println("\n\t----------------------------------");
                            for(i=0;i<ter.length();i++)
                            {               System.out.print("\n"+ter.charAt(i));
                                                    System.out.print("   |\t");
                                        for(j=0;j<ter.length();j++)
                                                    System.out.print(prec[i][j]+"\t");            }
                            System.out.printf("\n%20s%15s\n\n","\n\nSTACK","INPUT");
            while(true)
            {   for(i=0;i<stack.size();i++)
                                                    System.out.print((stack.get(i)+" ").replaceAll("i","id"));
                if(stack.size()>3)
                                                    System.out.print("\t");
                else
                System.out.printf("\t\t");
                for(i=ip.size()-1;i>=0;i--)
                System.out.print((ip.get(i)+" ").replaceAll("i","id"));
                                        System.out.println();
                a = (char)stack.peek();
                                        if(ter.indexOf(a)<0)
                                                    a = (char)stack.get(stack.size()-2);
                b = (char)ip.peek();
                p = prec[ter.indexOf(a)][ter.indexOf(b)];
                if(p=='A')
                {               System.out.println("\nAccept.");
                    break;               }
                else if(p=='<'||p=='=')
                {               ip.pop();
                    stack.push((Character)b);   }
                else if(p=='>')
                {               for(j=1;j<stack.size();j++)
                                        temp = temp.concat(stack.get(j).toString());
                            for(j=0;j<temp.length();j++)
                            {               if(Arrays.asList(prod).contains(temp.substring(j)))
                                        {               for(k=0;k<temp.substring(j).length();k++)
                                                                stack.pop();
                                                    break;  }              }
                stack.push((Character)prod[0].charAt(0));
                                                    temp="";              }
                                        else
                                        {               System.out.println("\nERROR.");
                                                        break;                   }              }               }               }


Intermediate Code Generation
 
Code :
 
#include<stdio.h>
#include<conio.h>
#include<string.h>
int prec(char a)
{
int precedence;
if(a=='/')
precedence=1;
if(a=='*')
precedence=2;
if(a=='+')
precedence=3;
if(a=='-')
precedence=4;
return precedence;
}
void main()
{
char *input;
int i,j,k,l,m,n,o,p,q,pre[1000],index[1000],temp,temp1,ind,ind1,ind2,in,flag;
char opr[1000],temp2,t[1000],op1[10],op2[10],op;
input=(char*)malloc(50*sizeof(char));
printf("Enter the Input string: ");
scanf("%s",input);
printf("The TAC generated is:");
n=strlen(input);
j=0;
for(i=2;i<n;i++)
{
if(input[i]=='/'||input[i]=='*'||input[i]=='+'||input[i]=='-')
{
op=input[i];
opr[j]=op;
index[j]=i;
pre[j]=prec(op);
j++;
}
}
for(i=0;i<j;i++)
{
for(k=0;k<j-1;k++)
{
if(pre[k]>pre[k+1])
{
temp=pre[k+1];
pre[k+1]=pre[k];
pre[k]=temp;
temp1=index[k+1];index[k+1]=index[k];
index[k]=temp1;
temp2=opr[k+1];
opr[k+1]=opr[k];
opr[k]=temp2;
}}}
for(i=0;i<j;i++)
{
flag=0;
op1[0]=' ';
op1[1]=' ';
op2[0]=' ';
op2[1]=' ';
ind=index[i];
index[i]=-1;
if(input[ind-2]=='T')
{
op1[0]='T';
op1[1]=input[ind-1];
flag=1;
}
else
{
op1[0]=input[ind-1];
}
if(input[ind+1]=='T')
{
op2[0]='T';
op2[1]=input[ind+2];
}
else
{
op2[0]=input[ind+1];
}
printf("\nT%d=%s%c %s",i,op1,opr[i],op2);
in=48+i;
input[ind]=in;
if(flag==1)
{
input[ind-1]=in;
}
else
{
input[ind-1]='T';
}
if(input[ind-2]=='T'&&input[ind]=='T')
{
o=n-3;


for(m=0;m<j;m++)
{
if(index[m]>ind)
{
index[m]-=3;
}
}
for(m=ind;m<o;m++)
{
input[m]=input[m+3];
}
}
if(input[ind-2]=='T'&&input[ind+1]!='T'||input[ind-2]!='T'&&input[ind+1]=='T')
{
o=n-2;
for(m=0;m<j;m++)
{
if(index[m]>ind)
{
index[m]=index[m]-2;
}
}
if(input[ind-2]=='T')
{
q=ind;
}
if(input[ind+1]=='T')
{
q=ind+1;
}
for(m=q;m<o;m++)
{
input[m]=input[m+2];
}
}
if(input[ind-2]!='T'&&input[ind+1]!='T')
{
o=n-1;
for(m=0;m<j;m++)
{
if(index[m]>ind)
{
index[m]-=1;
}
}
for(m=ind+1;m<o;m++)
{
input[m]=input[m+1];
}
}
for(p=o;p<=n;p++)


{
input[p]=' ';
}}
printf("\n%c=T%d",input[0],j-1);
}


Code Optimization Techniques
 
Common Subexpression Elimination
import java.io.*;
import java.util.*;
class CSE{
        public static void main(String args[])throws IOException{
                BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream("input.txt")));                                     PrintWriter pw=new PrintWriter(new FileOutputStream(new File("output.txt")),true);                                                       Vector L = new Vector();
                String s;
                Boolean flag=false;
                while((s=br.readLine())!=null){
                        flag=false;
                        String r=s.substring(s.indexOf("=")+1);
                        for(int i=0;i < L.size();i++){
                                if((L.elementAt(i)).equals(r))
                                flag=true; 
                        }
                        if(!flag){
                                L.addElement(r);        
                                pw.println(s);
                        }
                }
        }
}


Input.txt
t1 = -c
t2 = a + b
t3 = d + 5
t4 = a + b
t5 = -c


Output.txt
t1 = -c
t2 = a + b
t3 = d + 5


                                                DeadCode


import java.util.Vector;
public class DeadCode {
        public static void main(String[] args)
        {    int a,i=0,b,var2,c=0;
            a=4;
            b=0;
            var2=0;
            Vector v= new Vector();
            v.add("a=2;\n");
            v.add("b=4;\n");
v.add("L1: var2=b;\n");
v.add("if(var2!=0) goto L2;\ngoto L3;" );
v.add("L2: c=a*a;\n" );
v.add("L3: c= a/2;" );
            System.out.println(v.get(0));
            a=4;
            System.out.println(v.get(1));
            b=0;
            System.out.println(v.get(2));
            var2=b;
            if ( var2!=0)
            {    System.out.println("L2");
                c=a*a;
                System.out.println(c);     }
            else
            {    System.out.println("L3");
                c=a/2;
                System.out.println(c);     }
            System.out.println("Original Code:\n");
            for(i=0;i<v.size(); i++)
                System.out.println(v.get(i));
            v.removeElementAt(3);
            v.removeElementAt(3);
            System.out.println("Optimised Code:\n");
        for(i=0 ;i<v.size(); i++)
                System.out.println(v.get(i));     
}     }        








2 Pass Assembler
 
/*
    Program to implement 2 Pass Assembler in Java
    Author: Manav Sanghavi            Author Link: https://www.facebook.com/manav.sanghavi
    www.pracspedia.com
*/
import java.util.*;
import java.io.*;


class Tuple {
    String mnemonic, bin_opcode, type;
    int length;
    
    Tuple() {}
    
    Tuple(String s1, String s2, String s3, String s4) {
            mnemonic = s1;
            bin_opcode = s2;
            length = Integer.parseInt(s3);
            type = s4;
    }
}


class SymTuple {
    String symbol, ra;
    int value, length;
    
    SymTuple(String s1, int i1, int i2, String s2) {
            symbol = s1;
            value = i1;
            length = i2;
            ra = s2;
    }
}


class LitTuple {
    String literal, ra;
    int value, length;
    
    LitTuple() {}
    
    LitTuple(String s1, int i1, int i2, String s2) {
            literal = s1;
            value = i1;
            length = i2;
            ra = s2;
    }
}


class TwoPassAssembler {
    static int lc;
    static List<Tuple> mot;
    static List<String> pot;
    static List<SymTuple> symtable;
    static List<LitTuple> littable;
    static List<Integer> lclist;
    static Map<Integer, Integer> basetable;
    static PrintWriter out_pass2;
    static PrintWriter out_pass1;
    static int line_no;
    
    public static void main(String args[]) throws Exception {
            initializeTables();
            System.out.println("====== PASS 1 ======\n");
            pass1();
            System.out.println("\n====== PASS 2 ======\n");
            pass2();
    }
    
    static void pass1() throws Exception {
            BufferedReader input = new BufferedReader(new InputStreamReader(new FileInputStream("input.txt")));
            out_pass1 = new PrintWriter(new FileWriter("output_pass1.txt"), true);
            PrintWriter out_symtable = new PrintWriter(new FileWriter("out_symtable.txt"), true);
            PrintWriter out_littable = new PrintWriter(new FileWriter("out_littable.txt"), true);
            String s;
            while((s = input.readLine()) != null) {
                    StringTokenizer st = new StringTokenizer(s, " ", false);
                    String s_arr[] = new String[st.countTokens()];
                    for(int i=0 ; i < s_arr.length ; i++) {
                            s_arr[i] = st.nextToken();
                    }
                    if(searchPot1(s_arr) == false) {
                            searchMot1(s_arr);
                            out_pass1.println(s);
                    }
                    lclist.add(lc);
            }
            int j;
            String output = new String();
            System.out.println("Symbol Table:");
            System.out.println("Symbol        Value  Length   R/A");
            for(SymTuple i : symtable) {
                    output = i.symbol;
                    for(j=i.symbol.length() ; j < 10 ; j++) {
                            output += " ";
                    }
                    output += i.value;
                    for(j=new Integer(i.value).toString().length() ; j < 7 ; j++) {
                            output += " ";
                    }
                    output += i.length + "            " + i.ra;
                    System.out.println(output);
                    out_symtable.println(output);
            }
            System.out.println("\nLiteral Table:");
            System.out.println("Literal   Value  Length   R/A");
            for(LitTuple i : littable) {
                    output = i.literal;
                    for(j=i.literal.length() ; j < 10 ; j++) {
                            output += " ";
                    }
                    output += i.value;
                    for(j=new Integer(i.value).toString().length() ; j < 7 ; j++) {
                            output += " ";
                    }
                    output += i.length + "            " + i.ra;
                    System.out.println(output);
                    out_littable.println(output);
            }
    }
    
    static void pass2() throws Exception {
            line_no = 0;
            out_pass2 = new PrintWriter(new FileWriter("output_pass2.txt"), true);
            BufferedReader input = new BufferedReader(new InputStreamReader(new FileInputStream("output_pass1.txt")));
            String s;
            System.out.println("Pass 2 input:");
            while((s = input.readLine()) != null) {
                    System.out.println(s);
                    StringTokenizer st = new StringTokenizer(s, " ", false);
                    String s_arr[] = new String[st.countTokens()];
                    for(int i=0 ; i < s_arr.length ; i++) {
                            s_arr[i] = st.nextToken();
                    }
                    if(searchPot2(s_arr) == false) {
                            searchMot2(s_arr);
                    }
                    line_no++;
            }
            System.out.println("\nPass 2 output:");
            input = new BufferedReader(new InputStreamReader(new FileInputStream("output_pass2.txt")));
            while((s = input.readLine()) != null) {
                    System.out.println(s);
            }
    }
    
    static boolean searchPot1(String[] s) {
            int i = 0;
            int l = 0;
            int potval = 0;
            
            if(s.length == 3) {
                    i = 1;
            }
            s = tokenizeOperands(s);
            
            if(s[i].equalsIgnoreCase("DS") || s[i].equalsIgnoreCase("DC")) {
                    potval = 1;
            }
            if(s[i].equalsIgnoreCase("EQU")) {
                    potval = 2;
            }
            if(s[i].equalsIgnoreCase("START")) {
                    potval = 3;
            }
            if(s[i].equalsIgnoreCase("LTORG")) {
                    potval = 4;
            }
            if(s[i].equalsIgnoreCase("END")) {
                    potval = 5;
            }
            
            switch(potval) {
                    case 1:
                            // DS or DC statement
                            String x = s[i+1];
                            int index = x.indexOf("F");
                            if(i == 1) {
                                    symtable.add(new SymTuple(s[0], lc, 4, "R"));
                            }
                            if(index != 0) {
                                    // Ends with F
                                    l = Integer.parseInt(x.substring(0, x.length()-1));
                                    l *= 4;
                            } else {
                                    // Starts with F
                                    for(int j=i+1 ; j<s.length ; j++) {
                                            l += 4;
                                    }
                            }
                            lc += l;
                            return true;
                    
                    case 2:
                            // EQU statement
                            if(!s[2].equals("*")) {
                                    symtable.add(new SymTuple(s[0], Integer.parseInt(s[2]), 1, "A"));
                            } else {
                                    symtable.add(new SymTuple(s[0], lc, 1, "R"));
                            }
                            return true;
                    
                    case 3:
                            // START statement
                            symtable.add(new SymTuple(s[0], Integer.parseInt(s[2]), 1, "R"));
                            return true;
                    
                    case 4:
                            // LTORG statement
                            ltorg(false);
                            return true;
                    
                    case 5:
                            // END statement
                            ltorg(true);
                            return true;
            }
            return false;
    }
    
    static void searchMot1(String[] s) {
            Tuple t = new Tuple();
            int i = 0;
            if(s.length == 3) {
                    i = 1;
            }
            s = tokenizeOperands(s);
            for(int j=i+1 ; j < s.length ; j++) {
                    if(s[j].startsWith("=")) {
                            littable.add(new LitTuple(s[j].substring(1, s[j].length()), -1, 4, "R"));
                    }
            }
            if((i == 1) && (!s[0].equalsIgnoreCase("END"))) {
                    symtable.add(new SymTuple(s[0], lc, 4, "R"));
            }
            for(Tuple x : mot) {
                    if(s[i].equals(x.mnemonic)) {
                            t = x;
                            break;
                    }
            }
            lc += t.length;
    }
    
    static void ltorg(boolean isEnd) {
            Iterator<LitTuple> itr = littable.iterator();
            LitTuple lt = new LitTuple();
            boolean isBroken = false;
            while(itr.hasNext()) {
                    lt = itr.next();
                    if(lt.value == -1) {
                            isBroken = true;
                            break;
                    }
            }
            if(!isBroken) {
                    return;
            }
            if(!isEnd) {
                    while(lc%8 != 0) {
                            lc++;
                    }
            }
            lt.value = lc;
            lc += 4;
            while(itr.hasNext()) {
                    lt = itr.next();
                    lt.value = lc;
                    lc += 4;
            }
    }
    
    static boolean searchPot2(String[] s) {
            int i = 0;
            
            if(s.length == 3) {
                    i = 1;
            }
            if(Collections.binarySearch(pot, s[i]) >= 0) {
                    if(s[i].equalsIgnoreCase("USING")) {
                            s = tokenizeOperands(s);
                            
                            if(s[i+1].equals("*")) {
                                    s[i+1] = lclist.get(line_no) + "";
                            } else {
                                    for(int j=i+1 ; j<s.length ; j++) {
                                            int value = getSymbolValue(s[j]);
                                            if(value != -1) {
                                                    s[j] = value + "";
                                            }
                                    }
                            }
                            basetable.put(new Integer(s[i+2].trim()), new Integer(s[i+1].trim()));
                    }
                    return true;
            }
            return false;
    }
    
    static void searchMot2(String[] s) {
            Tuple t = new Tuple();
            int i = 0;
            int j;
            
            if(s.length == 3) {
                    i = 1;
            }
            s = tokenizeOperands(s);
            
            for(Tuple x : mot) {
                    if(s[i].equals(x.mnemonic)) {
                            t = x;
                            break;
                    }
            }
            
            String output = new String();
            String mask = new String();
            if(s[i].equals("BNE")) {
                    mask = "7";
            } else if(s[i].equals("BR")) {
                    mask = "15";
            } else {
                    mask = "0";
            }
            if(s[i].startsWith("B")) {
                    if(s[i].endsWith("R")) {
                            s[i] = "BCR";
                    } else {
                            s[i] = "BC";
                    }
                    List<String> temp = new ArrayList<>();
                    for(String x : s) {
                            temp.add(x);
                    }
                    temp.add(i+1, mask);
                    s = temp.toArray(new String[0]);
            }
            if(t.type.equals("RR")) {
                    output = s[i];
                    for(j=s[i].length() ; j<6 ; j++) {
                            output += " ";
                    }
                    for(j=i+1 ; j<s.length ; j++) {
                            int value = getSymbolValue(s[j]);
                            if(value != -1) {
                                    s[j] = value + "";
                            }
                    }
                    output += s[i+1];
                    for(j=i+2 ; j<s.length ; j++) {
                            output += ", " + s[j];
                    }
            } else {
                    output = s[i];
                    for(j=s[i].length() ; j<6 ; j++) {
                            output += " ";
                    }
                    for(j=i+1 ; j<s.length-1 ; j++) {
                            int value = getSymbolValue(s[j]);
                            if(value != -1) {
                                    s[j] = value + "";
                            }
                    }
                    s[j] = createOffset(s[j]);
                    output += s[i+1];
                    for(j=i+2 ; j<s.length ; j++) {
                            output += ", " + s[j];
                    }
            }
            out_pass2.println(output);
    }
    
    static String createOffset(String s) {
            String original = s;
            Integer[] key = basetable.keySet().toArray(new Integer[0]);
            int offset, new_offset;
            int index = 0;
            int value = -1;
            int index_reg = 0;
            if(s.startsWith("=")) {
                    value = getLiteralValue(s);
            } else {
                    int paranthesis = s.indexOf("(");
                    String index_string = new String();
                    if(paranthesis != -1) {
                            s = s.substring(0, s.indexOf("("));
                            index_string = original.substring(original.indexOf("(")+1, original.indexOf(")"));
                            index_reg = getSymbolValue(index_string);
                    }
                    value = getSymbolValue(s);
            }
            offset = Math.abs(value - basetable.get(key[index]));
            for(int i=1 ; i<key.length ; i++) {
                    new_offset = Math.abs(value - basetable.get(key[i]));
                    if(new_offset < offset) {
                            offset = new_offset;
                            index = i;
                    }
            }
            String result = offset + "(" + index_reg + ", " + key[index] + ")";
            return result;
    }
    
    static int getSymbolValue(String s) {
            for(SymTuple st : symtable) {
                    if(s.equalsIgnoreCase(st.symbol)) {
                            return st.value;
                    }
            }
            return -1;
    }
    
    static int getLiteralValue(String s) {
            s = s.substring(1, s.length());
            for(LitTuple lt : littable) {
                    if(s.equalsIgnoreCase(lt.literal)) {
                            return lt.value;
                    }
            }
            return -1;
    }
    
    static String[] tokenizeOperands(String[] s) {
            List<String> temp = new LinkedList<>();
            for(int j=0 ; j<s.length-1 ; j++) {
                    temp.add(s[j]);
            }
            StringTokenizer st = new StringTokenizer(s[s.length-1], " ,", false);
            while(st.hasMoreTokens()) {
                    temp.add(st.nextToken());
            }
            s = temp.toArray(new String[0]);
            return s;
    }
    
    static void initializeTables() throws Exception {
            symtable = new LinkedList<>();
            littable = new LinkedList<>();
            lclist = new ArrayList<>();
            basetable = new HashMap<>();
            mot = new LinkedList<>();
            pot = new LinkedList<>();
            String s;
            BufferedReader br;
            br = new BufferedReader(new InputStreamReader(new FileInputStream("mot.txt")));
            while((s = br.readLine()) != null) {
                    StringTokenizer st = new StringTokenizer(s, " ", false);
                    mot.add(new Tuple(st.nextToken(), st.nextToken(), st.nextToken(), st.nextToken()));
            }
            br = new BufferedReader(new InputStreamReader(new FileInputStream("pot.txt")));
            while((s = br.readLine()) != null) {
                    pot.add(s);
            }
            Collections.sort(pot);
    }
}


Mot.txt
LA          01h          4          RX
SR          02h          2          RR
L           03h          4          RX
AR          04h          2          RR
A           05h          4          RX
C           06h          4          RX
BNE         07h          4          RX
LR          08h          2          RR
ST          09h          4          RX
BR          15h          2          RR


Pot.txt
START
END
LTORG
DC
DS
DROP
USING
EQU


Input.txt
PRGAM2          START   0
                USING   *,15
                LA          15,SETUP
                SR          TOTAL,TOTAL
AC              EQU         2
INDEX           EQU         3
TOTAL           EQU         4
DATABASE        EQU         13
SETUP           EQU         *
                USING   SETUP,15
                L           DATABASE,=A(DATA1)
                USING   DATAAREA,DATABASE
                SR          INDEX,INDEX
LOOP            L           AC,DATA1(INDEX)
                AR          TOTAL,AC
                A           AC,=F'5'
                ST          AC,SAVE(INDEX)
                A           INDEX,=F'4'
                C           INDEX,=F'8000'
                BNE         LOOP
                LR          1,TOTAL
                BR          14
                LTORG
SAVE            DS          3F
DATAAREA        EQU         *
DATA1           DC          F'25,26,27'
                END
2 Pass Macro-Processor
 
Code :
import java.util.*;
import java.io.*;
class MntTuple
{                  String name;
                    int index;
                    MntTuple(String s, int i) {
                                    name = s;
                                    index = i;                   }
                    public String toString() {
                                    return("[" + name + ", " + index + "]");                       }                  }
class MacroProcessor {
                    static List<MntTuple> mnt;
                    static List<String> mdt;
                    static int mntc;
                    static int mdtc;
                    static int mdtp;
                    static BufferedReader input;
                    static List<List <String>> ala;
                    static Map<String, Integer> ala_macro_binding;
                    public static void main(String args[]) throws Exception {
                                    initializeTables();
                                    System.out.println("===== PASS 1 =====\n");
                                    pass1();
                                    System.out.println("\n===== PASS 2 =====\n");
                                    pass2();                                    }
                    static void pass1() throws Exception {
                                    String s = new String();
                                    input = new BufferedReader(new InputStreamReader(new FileInputStream("input.txt")));
                                    PrintWriter output = new PrintWriter(new FileOutputStream("output_pass1.txt"), true);
                                    while((s = input.readLine()) != null) {
                                                    if(s.equalsIgnoreCase("MACRO")) {
                                                                    processMacroDefinition();
                                                    } else {
                                                                    output.println(s);                  }                 }
                                    System.out.println("ALA:");
                                    showAla(1);
                                    System.out.println("\nMNT:");
                                    showMnt();
                                    System.out.println("\nMDT:");
                                    showMdt();            }
                    static void processMacroDefinition() throws Exception {
                                    String s = input.readLine();
                                    String macro_name = s.substring(0, s.indexOf(" "));
                                    mnt.add(new MntTuple(macro_name, mdtc));
                                    mntc++;
                                    pass1Ala(s);
                                    StringTokenizer st = new StringTokenizer(s, " ,", false);
                                    String x = st.nextToken();
                                    for(int i=x.length() ; i<12 ; i++) {
                                                    x += " ";                                    }
                                    String token = new String();
                                    int index;
                                    token = st.nextToken();
                                    x += token;
                                    while(st.hasMoreTokens()) {
                                                    token = st.nextToken();
                                                    x += "," + token;                                    }
                                    mdt.add(x);
                                    mdtc++;
                                    addIntoMdt(ala.size()-1);                                  }
                    static void pass1Ala(String s) {
                                    StringTokenizer st = new StringTokenizer(s, " ,", false);
                                    String macro_name = st.nextToken();
                                    List<String> l = new ArrayList<>();
                                    int index;
                                    while(st.hasMoreTokens()) {
                                                    String x = st.nextToken();
                                                    if((index = x.indexOf("=")) != -1) {
                                                                    x = x.substring(0, index);                                   }
                                                    l.add(x);                                    }
                                    ala.add(l);
                                    ala_macro_binding.put(macro_name, ala_macro_binding.size());                }
                    static void addIntoMdt(int ala_number) throws Exception {
                                    String temp = new String();
                                    String s = new String();
                                    List l = ala.get(ala_number);
                                    boolean isFirst;
                                    while(!s.equalsIgnoreCase("MEND")) {
                                                    isFirst = true;
                                                    s = input.readLine();
                                                    String line = new String();
                                                    StringTokenizer st = new StringTokenizer(s, " ,", false);
                                                    temp = st.nextToken();
                                                    for(int i=temp.length() ; i<12 ; i++) {
                                                                    temp += " ";           }
                                                    line += temp;
                                                    while(st.hasMoreTokens()) {
                                                                    temp = st.nextToken();
                                                                    if(temp.startsWith("&")) {
                                                                                    int x = l.indexOf(temp);
                                                                                    temp = ",#" + x;
                                                                                    isFirst = false;
                                                                    } else if(!isFirst) {
                                                                                    temp = "," + temp;               }
                                                                    line += temp;          }
                                                    mdt.add(line);
                                                    mdtc++;                                   }                                  }
                    static void showAla(int pass) throws Exception {
                                    PrintWriter out = new PrintWriter(new FileOutputStream("out_ala_pass" + pass + ".txt"), true);
                                    for(List l : ala) {
                                                    System.out.println(l);
                                                    out.println(l);          }                 }
                    
                    static void showMnt() throws Exception {
                                    PrintWriter out = new PrintWriter(new FileOutputStream("out_mnt.txt"), true);
                                    for(MntTuple l : mnt) {
                                                    System.out.println(l);
                                                    out.println(l);          }                 }
                    static void showMdt() throws Exception {
                                    PrintWriter out = new PrintWriter(new FileOutputStream("out_mdt.txt"), true);
                                    for(String l : mdt) {
                                                    System.out.println(l);
                                                    out.println(l);                          }                                     }
                    static void pass2() throws Exception {
                                    input = new BufferedReader(new InputStreamReader(new FileInputStream("output_pass1.txt")));
                                    PrintWriter output = new PrintWriter(new FileOutputStream("output_pass2.txt"), true);
                                    String token = new String();
                                    String s;
                                    while((s = input.readLine()) != null) {
                                                    StringTokenizer st = new StringTokenizer(s, " ", false);
                                                    while(st.hasMoreTokens()) {
                                                                    token = st.nextToken();
                                                                    if(st.countTokens() > 2) {
                                                                                    token = st.nextToken();                                    }
                                                                    MntTuple x = null;
                                                                    for(MntTuple m : mnt) {
                                                                                    if(m.name.equalsIgnoreCase(token)) {
                                                                                                    x = m;
                                                                                                    break;                        }                                 }
                                                                    if(x != null) {
                                                                                    mdtp = x.index;
                                                                                    List<String> l = pass2Ala(s);
                                                                                    mdtp++;
                                                                                    String temp = new String();
                                                                                    while(!(temp = mdt.get(mdtp)).trim().equalsIgnoreCase("MEND")) {
                                                                                                    String line = new String();
                                                                                                    StringTokenizer st2 = new StringTokenizer(temp, " ,",false);
                                                                                                    for(int i=0 ; i<12 ; i++) {
                                                                                                                    line += " ";               }
                                                                                                    String opcode = st2.nextToken();
                                                                                                    line += opcode;
                                                                                                    for(int i=opcode.length() ; i<24 ; i++) {
                                                                                                                    line += " ";               }
                                                                                                    line += st2.nextToken();
                                                                                                    while(st2.hasMoreTokens()) {
                                                                                                                    String token2 = st2.nextToken();
                                                                                                                    int index;
                                                                                                                    if((index = token2.indexOf("#")) != -1) {
                                                                                                                                        line += "," + l.get(Integer.parseInt(token2.substring(index+1,index+2)));           }                 }
                                                                                                    mdtp++;
                                                                                                    output.println(line);
                                                                                                    System.out.println(line);                  }
                                                                                    break;
                                                                    } else {  output.println(s);
                                                                                    System.out.println(s);
                                                                                    break;                        }                 }                  }
                                    System.out.println("\nALA:");
                                    showAla(2);                            }
                    static List<String> pass2Ala(String s) {
                                    StringTokenizer st = new StringTokenizer(s, " ", false);
                                    int num_tokens = st.countTokens();
                                    String macro_name = st.nextToken();
                                    int ala_no = ala_macro_binding.get(macro_name);
                                    List<String> l = ala.get(ala_no);
                                    int ctr = 0;
                                    StringTokenizer st2 = null;
                                    try {                            st2 = new StringTokenizer(st.nextToken(), ",", false);
                                                    while(st2.hasMoreTokens()) {
                                                                    l.set(ctr, st2.nextToken());
                                                                    ctr++;        }
                                    } catch(Exception e) {}
                                    if(ctr < num_tokens) {
                                                    String s2 = mdt.get(mdtp);
                                                    StringTokenizer st3 = new StringTokenizer(s2, " ,", false);
                                                    String token = new String();
                                                    int index = 0;
                                                    while(st3.hasMoreTokens()) {
                                                                    token = st3.nextToken();
                                                                    if((index = token.indexOf("=")) != -1) {
                                                                                    try {            l.set(ctr++, token.substring(index+1, token.length()));
                                                                                    } catch(Exception e) {}   }                  }                                  }
                                    ala.set(ala_no, l);
                                    return l;                    }
                    static void initializeTables() {
                                    mnt = new LinkedList<>();
                                    mdt = new ArrayList<>();
                                    ala = new LinkedList<>();
                                    mntc = 0;
                                    mdtc = 0;
                                    ala_macro_binding = new HashMap<>();                 }                  }
 
Text File :
MACRO
INCR1           &FIRST,&SECOND=DATA9
A               1,&FIRST
L               2,&SECOND
MEND
MACRO
INCR2           &ARG1,&ARG2=DATA5
L               3,&ARG1
ST          4,&ARG2
MEND
PRG2            START
                USING                       *,BASE
                INCR1                       DATA1
                INCR2                       DATA3,DATA4
FOUR            DC                          F'4'
FIVE            DC                          F'5'
BASE            EQU                         8
TEMP            DS                          1F
                DROP                        8
                END